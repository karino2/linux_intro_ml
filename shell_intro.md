---
title: "環境設定のためのシェル入門"
layout: page
---

機械学習屋は通常のシスアドほどはシェルに詳しい必要はありません。

ですがコンテナとインスタンスの設定は凄くしょっちゅうやる事になるので、
簡単なトラブルシューティングは自分で出来る方が良いです。
また、大きな学習データを扱うのにシェルを使うケースもちょこちょこ出てきます。

ここではそうした事を踏まえて、機械学習で必要な程度のシェルの入門をしたいと思います。

良くある設定として、以下が理解出来るくらいを目指します。（これは私のインスタンスの設定用スクリプトです）

- [GCP Setup, debian, non gpu](https://gist.github.com/karino2/347f40df3b95a1de77fec240d45b3fde#file-setup-sh-L28-L29)

# いろいろなクオートと変数の展開

シェルの文字列のクオートには、シングルクオートとダブルクオートとバッククオートの三種類があり、それぞれ意味が違います。

### echoに見る、クオートが無い場合とある場合の違い

echoで、「Hello  World」と、間に空白を二つ入れたいとします。
以下のようにすると、

```
$ echo Hello  World
Hello World
```

空白が一つになってしまいます。

echoコマンドからは、`echo Hello  World`というのは、

- 第一引数としてHello
- 第二引数としてWorld

が渡されている、と見えて、間の空白というのはシェルが処理する事になります。

シェルは空白で区切って最初の文字列をコマンド、それ以降を引数として配列に詰めて渡します。
この時、間の空白が幾つかとかはシェルは気にしません。そしてechoまで辿り着いた時には、間の空白が二つあったという情報は失われます。

では空白を二つ挟んだ結果を出したい場合はどうしたらいいでしょう？
ダブルクオートで囲むのが普通の解決策です。

```
$ echo "Hello  World"
```

こうすると、echoからは第一引数に「Hello  World」が渡された、と見えます。
引数は一つと解釈されます。これはechoというよりはシェルの振る舞いなのでそのほかのコマンドでも同じ事が言えます。（あとでシェルスクリプトをやった時にさらに確認します）


### シェルの変数

シェルには変数という物があります。
変数はイコールで代入する事で作られます。
例えば以下でHOGEという変数が出来ます。

```
$ HOGE=abc
```

これでHOGEという変数にabcという文字列が入ります。

変数は参照する時はドル記号をつけます。例えばechoを使うと、以下のようになります。

```
$ echo $HOGE
abc
```

シェルは、`$HOGE`とあったら変数の中身に置き換えてechoに渡します。
echoコマンドからはHOGEという変数だったという事実は分からず、abcという文字列が最初から渡されたのと区別出来ません。

### シングルクオートとダブルクオートと変数展開

文字列をダブルクオートで囲むと、中に変数があった場合、それが展開されます。

```
$ echo "ika$HOGE"
ikaabc
```

ですが、以下のようにすると、何も表示されません。

```
$ echo "$HOGEika"

```

これは、`$HOGE`という変数のあとにikaがあるのではなく、`$HOGEika`という別の変数があると勘違いする為です。

HOGEで切りたい場合は中括弧でくくります。

```
$ echo "${HOGE}ika"
abcika
```

シェルでは、文字列をシングルクオートでくくる事も出来ます。
シングルクオートの場合、中の変数は展開されません。

```
$ echo '${HOGE}ika'
${HOGE}ika
```

### バッククオートと`$()`

シェルスクリプトにはさらに、バッククオート、つまり`\``でくくる、というのがあります。
バッククオートはプログラム以外ではあまり使わないのでキーボード上で探さないといけない人もいるかもしれませんね。（なお私の手元のキーボードではシフトを押しながらアットマークのキーでした）

バッククオートで囲まれた部分は、「その中をシェルスクリプトとして、子プロセスで実行し、そこで得られた標準出力で置き換える」という機能になります。

言葉にするとややこしいので例をみましょう。

まず一番簡単なのがechoを使う例です。

```
$ echo hoge_`echo ika`_fuga
hoge_ika_fuga
```

バッククオートの中は`echo ika`なので、これを実行した結果の標準出力、つまり`ika`で展開されます。

もう少し他の例も見て見ましょう。例えば以下みたいなスクリプトを実行してみましょう。

```
~$ echo hoge_`cd /etc; pwd`_fuga
hoge_/etc_fuga
~$
```

バッククオートの中は`cd /etc; pwd`なので標準出力には/etcでpwdした結果、つまり`/etc`が得られるでしょう。

ここで着目して欲しいのは、呼び出し元のシェルでは作業ディレクトリが/etcになってない、という所です。
バッククオートの中は子プロセスとして実行されるので、呼び出し元のシェルには影響がありません。
だからこの中でcdしても問題が無い。

なお、バッククオートの他に`$(シェルのコマンド)`という記法もあって、効果は一緒です。
つまり上記のechoは`echo hoge_$(cd /etc; pwd)_fuga`と書いても良い。
複数行に渡る場合はこちらが多く使われるようです。

### 実際の例

dockerのサイトからインストール方法を調べると、以下のようなスクリプトを実行せよ、と書かれています。（[GCP Setup, debian, non gpu](https://gist.github.com/karino2/347f40df3b95a1de77fec240d45b3fde)にも入っています）

```
curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg | sudo apt-key add -
```

curlやapt-keyなどはおいといて、URLの部分はここで学んだ知識が使われていますね。
curlはやめてechoにしてみましょう。

```
$ echo https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")
https://download.docker.com/linux/ubuntu
```

私の環境ではubuntuと展開されるようです。
`$()`の中を見るとドットで始まっています。これは解説してないですが、引数のファイルを現在のシェルで実行する、という機能です。実行されるシェルスクリプトを見てみましょう。

```
$ cat /etc/os-release
NAME="Ubuntu"
VERSION="18.04.3 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.3 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
```

どうやらこのLinuxがどういうディストリビューションか、とか、バージョンとかが書かれているようですね。これらは変数として代入されていきます。そしてこのスクリプトを実行したあとに`echo $ID`を実行しているので、このファイルに書かれているIDが展開された結果が標準出力に出るのでしょう。

せっかくなので試しにこの仮説があっているかを確認してみましょう。

```
$ . /etc/os-release
$ echo $ID
ubuntu
```

あってそうですね。

なお、`$()`の中は子プロセスで実行されるので、元のスクリプトではechoしたあとにはこの変数は消えているはずです。

このようにURLやファイルのパスの一部を作ったり、コマンドラインの引数の一部を使うのにバッククオートや`$()`は良く使われます。

# 環境変数入門

環境変数とは、シェルの設定を行う特殊な変数です。
環境変数回りのトラブルはちょくちょくあるので、簡単に基本を説明しておきます。

### envで環境変数を確認する

envというコマンドを実行すると、現在の環境変数の一覧が見れます。やってみましょう。

```
$ env
PWD=/home/karino2/Documents/linux_intro_ml
USER=karino2
HOME=/home/karino2
...その他一杯出力される...
```

これらは通常の変数として見る事も出来ます。例えばUSERを表示するなら、
これまで通りechoを使えば見る事が出来ます。

```
$ echo $USER
karino2
```

## 良く使う環境変数

機械学習をする人がお目にかかる環境変数はそんなに多くありません。
ざっと説明しておきます。

### PATHとwhichコマンド

シェルがコマンドを探すディレクトリの一覧が入っています。ディレクトリはコロンで区切られています。

```
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

人によってはもっといっぱいずらずら出てくるでしょう。
上記の例だと、/bin, /sbin, /usr/bin, /usr/bin, /usr/local/bin, /usr/local/sbinから実行コマンドを探します。

例えばpythonと打った場合、上記のディレクトリを順番に探していって、最初に見つかったpythonが実行されます。

なお、最初に見つかるpythonがどこにあるかはwhichコマンドで探せます。

```
$ which python
/usr/bin/python
```

/usr/binにあるらしいです。
なお、この場合は、以下のように実行するのと

```
$ python
```

以下のように実行するのは同じ事になります。

```
$ /usr/bin/python
```

このPATHにホームディレクトリのディレクトリを追加したり、新しくインストールしたアプリのディレクトリを追加したりする事があります。

特に良くあるのがaptやpipなどでインストールしたのに実行出来ない、という時に、このPATHが適切に更新されていない、というパターンです。
そういう場合は手で追加したあとにあとで説明するexportを使って動くか確認したりしていきます。


### USER

現在のユーザー名が入ります。
ユーザー名はインスタンスによって自分のローカルのマシンの名前だったりubuntuだったりdockerだったりgmailのアカウント名だったりするので、スクリプトを共有するのに`$USER`を使うのが良い事があります。

前述のセットアップのスクリプトでは、以下のように
usermodでdockerのグループに自身を加えていますね。

```
sudo usermod -a -G docker $USER
```

詳細はインスタンスのセットアップの所で説明しますが、これはdockerを使う為に必要な設定です。

### LD_LIBRARY_PATH

ロードする共有ファイルを検索するディレクトリの一覧が入っています。
共有ファイルというのはlibXXXX.soみたいな名前のファイルです。
数値計算ライブラリとかCUDAとかpythonの外の何かを必要とする時にインストールした物がうまく動かない時にこの辺を調べる事になります。

LD_LIBRARY_PATH周辺のトラブルはちょっと難度が高いので、少しチャレンジして無理だったらチーム内の詳しい人に聞いても良いと思います。
ただ一応名前くらい知っておくと、見よう見まねでトラブルシュートしないといけない時に役に立ちます。

### LANG

日本語がおかしい、みたいな時にたまにいじる必要があります。
en_USとかCとかja_JP.UTF8とかをごちゃごちゃやる必要があるかもしれません。

これもチームの詳しい人に聞いて良い奴ですが、名前くらい知っておくとピンチの時に役に立つかもしれません。

## 環境変数の更新とexport

環境変数を変更する時は、ただ新しい値を代入するだけじゃダメで、何故かexportという事をやらないといけません。

たとえばLANGをja_JP.UTF8に変更したい場合、以下のようにします。

```
$ LANG=ja_JP.UTF8
$ export LANG
```

また、以下のように書いても同じ意味になります。

```
$ export LANG=ja_JP.UTF8
```

この辺は「何故？」とか考えずに、こういう物だと飲み込んでください。

## 子プロセスと環境変数の継承と設定

機械学習やってて環境変数が出てくる一番重要なシチュエーションは「なんか環境変数が設定されない！」というトラブルの時です。

具体的にはJupyterからシェルコマンドを実行してaptやpipでインストールしたりした時にPython側に反映されない、とか、dockerコンテナ内で設定したかったのに間違ってホストに設定していたり、とか、tmux上で設定してログインシェルに反映されてないとかそういうのです。

そうしたトラブルを理解する為に、基本的な事を簡単に解説しておきます。


### 環境変数は親から継承される

あるプロセスを作ると、環境変数は基本的には親から継承されます。
継承というのはコピーされる、という事です。
だから親のプロセスに環境変数を設定して新しい子プロセスを作ると、基本的には親の環境変数が子に引き継がれます。

なお、明示的に引き継がせずに子プロセスを作る事は出来ますが、機械学習には必要無い知識です。

### 一度子プロセスが作られたあとにどちらかを変更しても反映されない

作成される時に引き継がれるのはコピーです。
ですから子プロセスが作られた時に親のプロセスの環境変数を変更しても子プロセスには反映されませんし、子プロセスの環境変数を設定しても親プロセスの環境変数は更新されません。

これは当たり前の事なのですが、意外と困るシチュエーションがあります。
少し具体例を見てみましょう。

**具体例1: シェルスクリプトで環境変数の更新が出来ない**

シェルスクリプトに関してはこのあと解説するのですが、
良く実行するコマンドをシェルスクリプトでまとめる、というのは良くやる事です。

ですが、このシェルスクリプトの実行方法を気を付けないと、
子プロセスで実行されていまって親のシェルの設定は変更出来ない、というのは良くあります。

基本的には`bash ファイル名`で実行すると子プロセスが実行され、`source ファイル名`や`. ファイル名`で実行すると現在のシェルで実行されるのですが、
Dockerfileやその他のプログラムから実行される時には解決策が無い場合もあります。

**具体例2: Jupyterのシェルコマンドで環境変数の更新をしてもPythonに反映されない**

Jupyterのシェルコマンドは（たぶん）Pythonの子プロセスとして実行されます。
だからこの中で例えばPythonのライブラリの検索に関する環境やLD_LIBRARY_PATHなどを変更しても、Pythonには反映させられません。

こういう時は「Jupyterを実行しているシェル」の環境変数をどうにか更新したあとに、Jupyterを再起動する必要があります。


# シェルスクリプト入門

本当に入門だけ。なるべくJupyter上でやろう。
